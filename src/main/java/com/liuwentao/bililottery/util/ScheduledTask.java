package com.liuwentao.bililottery.util;import com.liuwentao.bililottery.Entity.PostLottery;import com.liuwentao.bililottery.Entity.Reply;import com.liuwentao.bililottery.Service.LotteryResultService;import com.liuwentao.bililottery.Service.PostLotteryService;import com.liuwentao.bililottery.factory.ScheduledThreadPoolFactory;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;/** * Created by liuwentao on 2021/9/16 21:04 */@Slf4j@Componentpublic class ScheduledTask {    @Autowired    LotteryResultService lotteryResultService;    @Autowired    PostLotteryService postLotteryService;    // 从当下开始，每间隔5分钟从数据库获取将来5分钟内的抽奖；并封装成任务放到线程池    @Scheduled(fixedRate = 5 * 60 * 1000)    public void pushDataToThreadPool() {        // 首先set NextTime这个单例的时间为当下时间后一个小时那个时间点        log.info("执行一次定时任务");        Date currentTime = new Date();// 获取当前时间        NextTimeSingleTon nextTimeSingleTon = NextTimeSingleTon.getFlagSingleTon(); // 拿到单例        Long nextTimeMill = currentTime.getTime()+ 5 * 60 * 1000; // 下一次的毫秒数时间戳 「设定下一次时间为5分钟后」        Date nextTime = new Date(nextTimeMill);        nextTimeSingleTon.setFlag(nextTime);        // 然后去数据库查找(currentTime, nextTime]所有抽奖; 左右边界都是Date类型，数据库中变量也是Date类型，到时候可以直接用方法进行比较；        ScheduledExecutorService scheduledExecutorService = ScheduledThreadPoolFactory.createDefaultScheduledThreadPool("LotteryScheduledThreadPool:"); // 得到定时线程池对应的单例        // 接下来写从数据库中查找：已开奖（抽奖时间>=当前时间）/未开奖（抽奖时间<当前时间）  给sql语句传nextTime这个时间戳        List<PostLottery> postLotteryList = postLotteryService.findPostLotteryBetweenCurrentTimeAndNextTime(nextTime);        // 可以精确到秒  2017-4-16 12:43:37        DateFormat df = DateFormat.getDateTimeInstance();        log.info("查找出数据库中开奖时间在(" + df.format(currentTime) + "," +  df.format(nextTime) + "]" + "范围的记录：" + postLotteryList.toString());        // 依次将postLotteryList中所有抽奖放到线程池中延时执行        // 放线程池        for (PostLottery postLottery : postLotteryList) {            // 该定时抽奖距离当前时间的秒数            Date now = new Date();            long secondGap = (postLottery.getLotteryDateAndTime().getTime() - now.getTime()) / 1000; // 秒数            log.info("当前postLottery的id是：" + postLottery.getId() + "，距离当前时间准备开奖剩余的秒数：" + secondGap);            scheduledExecutorService.schedule(()->{                // 任务具体干什么；其实就是跟下面的立即抽奖一样了。。。                log.info("这是从数据库中定时取出的抽奖任务，线程池开始执行该抽奖任务，抽奖id是：" + postLottery.getId());                Lottery.getSingleTonLottery().lottery(postLottery.getId(), postLottery.getCount(), postLottery.isUnlimitedStart(), postLottery.isUnlimitedEnd(),                        postLottery.getStart(), postLottery.getEnd(), postLottery.isGetStart(), postLottery.isLetEnd(), postLottery.isDuplicatedUid(),                        postLottery.isOnlySpecified(), postLottery.getContentSpecified(), postLottery, true);            }, secondGap, TimeUnit.SECONDS);        }    }}